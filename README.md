## **Image Feed**

Многостраничное приложение предназначено для просмотра изображений через API Unsplash.

Цели приложения:
- Просмотр бесконечной ленты картинок из Unsplash Editorial.
- Просмотр краткой информации из профиля пользователя.

## **Ссылки**

- [Дизайн в Figma](https://www.figma.com/file/HyDfKh5UVPOhPZIhBqIm3q/Image-Feed-(YP)?type=design&node-id=334-4892&mode=design&t=hV7ThmC01hcgjD79-0)
- [Unsplash API](https://unsplash.com/documentation)

---

## Порядок сдачи домашнего задания:

1. Выполните задачу в Xcode.
2. Залейте готовую задачу на GitHub в отдельную ветку с названием sprint_XX. Важно:
- проект должен быть открытым!
- проект нужно выгрузить исходным кодом, то есть папкой со всеми файлами. Не надо загружать zip-архив — ревьюер не сможет его проверить!
3. Создайте Pull Request (ПР) и скопируйте ссылку на него. Вставьте её в специальную форму на сайте Практикума через кнопку «Сдать работу».

---

## Сдаём задачу спринта 8 на ревью (ветка sprint_08)

Вы завершили 8-й спринт и выполнили первые задачи по новому проекту Image Feed. Пришло время для ревью!
Вам нужно сдать проект, в котором есть:
- Свёрстан экран Launch Screen.
- Добавлен и свёрстан по макетам экран ленты изображений.

## Убедитесь, что:

1. Создан новый проект, в котором:
- iOS 13.0 указана как минимально поддерживаемая версия;
- в настройках основного таргета отключена сборка на iPad;
- проставлена только галочка поддержки портретной ориентации (в секции Device Orientation), а в Info удалены соответствующие значения для Supported interface orientations (iPhone);
- структура файлов совпадает со структурой, которую мы рассмотрели в теме «Инициализация второго проекта»;
- для проекта подключён Git — в меню Source Control в Xcode вам будут доступны меню управления репозиторием.
2. Свёрстан Launch Screen приложения:
- экран должен полностью соответствовать макету
3. Свёрстан главный экран с лентой изображений со следующими параметрами:
- лента содержит 20 фотографий;
- между фото есть отступ;
- края фотографий скруглены;
- на фото добавлен лейбл с текущей датой;
- на фото добавлена кнопка лайка;
- лайк проставлен у ячеек с чётным индексом и не проставлен — у нечётным;
- размеры, параметры и отступы элементов соответствуют макетам;
- высота ячейки зависит от размеров фото и является динамической.
4. Приложение запускается.
5. Элементы интерфейса адаптируются под разрешения экранов iPhone (вёрстка под iPad не предусмотрена).

---

## Сдаём задачу спринта 9 на ревью (ветка sprint_09)

Вы завершили 9-й спринт. Пришло время для ревью!
Вам нужно сдать проект, в котором есть:
- Экран профиля пользователя, свёрстанный кодом.
- Кнопка «Поделиться» на экране приложения.

## Убедитесь, что:

1. Экран профиля пользователя свёрстан кодом:
- создан соответствующий класс ProfileViewController;
- создан новый UIViewController в Storyboard;
- на него добавлен UIImageView, три UILabel и один UIButton;
- констрейнты расставлены нужным образом;
- из Figma выгружены соответствующие ресурсы (картинка для профиля и картинка для кнопки логаута) и подставлены в нужные элементы в ProfileViewController.
2. Добавлен экран отдельного изображения SingleImageViewController
- При открытии изображения на весь экран пользователь видит растянутое изображение до границ экрана.
- Изображение выровнено по центру.
- Вы добавили ScrollView на экран SingleImageViewController и выставили ему констрейнты, равные нулю со всех сторон.
- Добавлен outlet для  ScrollView (и назван, соответственно, scrollView).
3. На экране SingleImageViewController реализована кнопка «Поделиться»:
- Размеры и кнопка иконки соответствуют макету.
- Кнопка расположена над ScrollView, а не внутри него.
- Реализован метод didTapShareButton, который вызывается при тапе на кнопку.
- Добавлена функциональность шеринга картинки.

---

## Сдаём задачу спринта 10 на ревью (ветка sprint_10)

Вы завершили 10-й спринт и реализовали авторизацию в нашем приложении. Пришло время для ревью!
Вам нужно сдать проект, в котором есть:
- Экран авторизации с логотипом приложения и кнопкой «Войти».
- Авторизация реализована с помощью OAuth2.0.

## Убедитесь, что:

1. Ваше приложение зарегистрировано на сайте Unsplash.
2. Экран авторизации содержит логотип приложения и кнопку «Войти».
3. Для входа в приложение пользователь авторизуется через OAuth2.0:
- При входе в приложение пользователь видит splash-screen.
- После загрузки приложения открывается экран с возможностью авторизации.
- При нажатии на кнопку «Войти» открывается браузер на странице авторизации Unsplash.
- При нажатии на кнопку Login, если авторизация в Unsplash прошла успешно, браузер закрывается и выполняется POST-запрос для получения Auth Token.
- Если POST-запрос завершается успешно — экран авторизации скрывается, а в приложении открывается экран с лентой.
4. В проекте создан файл Constants.swift, в нём есть константы accessKey, secretKey, redirectURI и accessScope:
- Константы описаны внутри перечисления Constants статическими константами.
- В этих константах сохранены Access key, Secret key и Redirect URI вашего приложения.
- accessScope — список доступов, разделённых плюсом.
- Также добавлена константа defaultBaseURL — в неё сохранён базовый адрес API из документации. Эта константа должна быть типа URL.
5. Свёрстан контроллер WebView, его дизайн соответствует ТЗ.
6. Реализован KVO — приложение показывает, как обновляется прогресс загрузки веб-страницы.
7. Проверка необходимости авторизации выделена в отдельный контроллер SplashViewController:
- Создан стартовый контроллер, который выполняет проверку, был ли ранее авторизован пользователь.
- Если есть сохранённые данные об авторизации, пользователя отправляют на флоу галереи, если нет — на флоу авторизации.
- При первом запуске приложения пользователь видит SplashViewController, а затем — форму авторизации.
- При повторном запуске после ранее успешной авторизации пользователь сразу после SplashViewController попадает в галерею.
8. Добавлена структура для декодинга JSON-ответа от POST-запроса авторизации Unsplash — OAuthTokenResponseBody
9. Создан новый класс OAuth2Service:
- В нём объявлена функция fetchAuthToken, которая получает code на вход и, используя его, делает POST-запрос.
- Функция fetchAuthToken вторым аргументом получает completion — блок, который нужно вызвать при разборе результатов HTTP-запроса.
- Аргумент completion возвращает Swift.Result<String, Error>, где success соответствует только ситуации, когда в ответе на запрос был получен положительный HTTP статус код (значение в диапазоне 200 — 299), а в теле ответа получен и декодирован авторизационный токен. При этом блок completion вызван на главном потоке (DispatchQueue.main).
- Класс — синглтон, то есть представляет глобальную точку доступа и запрещает создание других экземпляров.
- В классе AuthViewController, там, где объявлен метод делегата func webViewViewController(_ vc: WebViewViewController, didAuthenticateWithCode code: String), вызван fetchAuthToken.
- В случае успешного выполнения запроса Bearer Token токен сохранён в User Defaults с использованием класса OAuth2TokenStorage.
10. Добавлено логирование ошибок в консоль; распечатаны:
- ошибочные кейсы, при получении опциональных значений, таких как URLComponents, URL, URLRequest;
- сетевые ошибки при работе метода URLSession.shared.dataTask;
- ошибки, которые вернул сервис Unsplash (с кодом ответа >=300);
- ошибка, которую может выкинуть декодер при получении OAuthTokenResponseBody.
11. В проекте не используется implicit unwrap и другие force-операции. Использовано безопасное извлечение значений опционалов и применен do-catch для throwable-методов.

---

## Сдаём задачу спринта 11 на ревью (ветка sprint_11)

Вы завершили 11-й спринт и доработали экран профиля. Пришло время для ревью!
Вам нужно сдать проект, в котором:
- Потенциальные гонки, которые могут возникнуть при выполнении POST-запроса на получение Auth Token от Unsplash, устранены двумя способами — с помощью отмены запроса и с помощью блокировки UI.
- Сделан сетевой слой для экрана профиля.
- Есть индикатор загрузки на запрос токена после регистрации.

## Убедитесь, что:

1. Устранено состояние гонки в OAuthService. Получившееся решение должно корректно отрабатываться в ситуациях, когда:
- fetchOAuthToken() был вызван два раза подряд с одинаковым code (второй вызов не дожидается завершения первого);
- fetchOAuthToken() был вызван сначала с одним code, но спустя некоторое временя, когда первый запрос ещё не успел завершиться, был вызван с другим значением кода.
2. Устранено состояние гонки c помощью блокировки UI:
- добавлен новый класс UIBlockingProgressHUD, который синхронизирует показ и скрытие ProgressHUD с блокировкой UI;
- сразу после закрытия WebView при авторизации (при получении CODE) показан индикатор активности — использован UIBlockingProgressHUD;
- при завершении запроса, независимо от результата, скрыт индикатор активности;
- пользователь не может повторно открыть экран с WebView, пока индикатор активности отображается на экране.
3. Сделан сетевой слой для экрана профиля. С технической точки зрения он состоит из двух сетевых запросов.
Первый запрос — получение базовой информации о пользователе GET /me — логин пользователя (username), имя и фамилия (first_name, last_name), короткая информация (bio):
- добавлен новый сервис ProfileService как синглтон;
- в него добавлена функция fetchProfile, которая получает данные пользователя через запрос GET /me, используя Bearer Token;
- с помощью этих данных мы обновляем лейблы на экране ProfileViewController;
- чтобы не показывать заглушки на экране профиля, мы перенесли получение данных профиля в SplashViewController. Теперь всегда отображаем данные, актуальные на момент запуска.
Второй запрос — получение публичной информации о пользователе GET /users/:username — URL для получения аватарки пользователя (profile_image):
- добавлен сервис ProfileImageService для получения URL аватарки пользователя;
- добавлен Observer для уведомления ProfileImageService.didChangeNotification.
4. Пока идёт загрузка данных профиля, показывается SplashViewController:
- убедитесь, что fetchProfile вызывается не только после непосредственно авторизации, но и если authToken уже присутствует на момент запуска из метода viewDidAppear.
5. Для отображения аватарки пользователя использована библиотека Kingfisher.
6. В проект добавлен SwiftKeychainWrapper через SPM:
- заменено использование OAuth2TokenStorage на хранение и получение из хранилища токена с использованием SwiftKeychainWrapper.
7. Добавлен вывод сообщений об ошибках в консоль:
- Обработан каждый вариант failure в методе data(for:) перед вызовом комплишена fulfillCompletionOnMainThread;
- Обработаны ошибки декодирования objectTask(for:), есть информация об ошибке и о данных, которые пытались декодировать;
- В каждом сервисе OAuth2Service, ProfileService, ProfileImageService обработан каждый полученный failure;
- Сообщения должны быть одинакового вида, можете придерживаться такого формата [название метода и/или сервиса]: [тип ошибки] [параметры с которыми получили ошибку]. Например, "[dataTask]: NetworkError - код ошибки 401".
8. При получении ошибки в сетевом запросе в AuthViewController нужно показать UIAlertController с заголовком «Что-то пошло не так(», подписью «Не удалось войти в систему» и кнопкой «Ок» для скрытия алерта.
9. Ключевое окно (keyWindow) создаётся из кода:
- изменён метод application(_:, configurationForConnecting:, options:), создающий UISceneConfiguration(name: "Default Configuration", ...), который возвращает созданную из кода конфигурацию (отличающуюся от стандартной, создаваемой из Info.plist);
- изменён метод func application(_:, configurationForConnecting:, options:), который теперь содержит создание rootViewController (а именно — SplashViewController) из кода;
- создан класс TabBarController, который в методе awakeFromNib настраивает свои дочерние контроллеры (viewControllers);
- класс SplashViewController свёрстан в коде, переход на экран авторизации работает корректно и визуально не отличается от версии, свёрстанной в Storyboard.

---

## Сдаём задачу спринта 12 на ревью (ветка sprint_12)

Вы завершили 12 спринт и выполнили задачи по проекту ImageFeed. Пришло время для ревью!
Вам нужно сдать проект, в котором:
- Создан сетевой слой для экрана с лентой фотографий.
- Реализована функциональность лайков.
- Добавлена возможность полноэкранного просмотра фотографий.
- Добавлена возможность выхода из аккаунта.

## Убедитесь, что:

1. В проекте реализована постраничная загрузка данных для ленты фотографий:
- добавлена структура для декодинга JSON-ответа от Unsplash — PhotoResult (а также вспомогательная структура UrlsResult для получения полей из urls);
- создана структура Photo, которая будет использоваться в UI части приложения;
- при получении ответа из сети формируется объект Photo для каждого PhotoResult;
- для получения даты createdAt: Date из PhotoResult\.createdAt использован ISO8601DateFormatter
- обработана ситуация с опциональным значением при получении даты.
- в таблице в ячейку с фото вместо текущей даты подставляется дата createdAt; чтобы из даты получить строку вроде 27 августа 2022, нужно использовать DateFormatter.
- объект форматтера нужно иметь в единственном экземпляре;
- создан новый класс ImagesListService;
- добавлено свойство photos: Photo для хранения последовательности всех загруженных из сети фотографий;
- в ImagesListService добавлена нотификация static let didChangeNotification = Notification.Name(rawValue: "ImagesListServiceDidChange");
- в классе ImagesListService объявлена функция fetchPhotosNextPage(), которая загружает очередную страницу. При этом —
    - функция внутри себя определяет номер следующей страницы для закачки (номер не должен сообщаться извне, как параметр функции);
    - если идёт закачка, то нового сетевого запроса не создаётся, а выполнение функции прерывается;
    - при получении новых фотографий массив photos обновляется из главного потока, а новые фото добавляются в конец массива;
    - после обновления значения массива photos публикуется нотификация ImagesListService.didChangeNotification.
- написана функция updateTableViewAnimated(), которая будет вызываться по нотификации ImagesListService.didChangeNotification (то есть когда очередная страница закачана) и будет анимированно обновлять состояние таблицы.
2. Реализована функциональность лайков:
- пользователь имеет возможность взаимодействовать с индикатором — создана кнопка с картинками-сердечками (UIButton);
- индикаторы располагаются на каждой картинке — кнопка с индикатором размещена в ячейке таблицы;
- в ячейку добавлен метод setIsLiked, который изменяет состояние (картинку) индикатора лайка;
- созданы @IBAction для реакции тапа по лайку и @IBOutlet для кнопки;
- обработана ситуация сетевой гонки с помощью блокирования UI интерфейса.
3. При тапе на картинку в общем списке изображений должен осуществляться переход на экран, где можно посмотреть полноразмерную версию фотографии (также фото можно зумить):
- для отображения картинки использован UIImageView;
- для просмотра картинки в масштабе использован UIScrollView;
- на время загрузки картинки показывается лоадер загрузки (используйте ProgressHUD);
- реализован парсинг поля со ссылкой на полноразмерную картинку;
- чтобы просматривать выбранную картинку из списка, реализован переход на новый контроллер;
- новому контроллеру для отображения выбранной картинки нужна передача информации о ней;
- реализована кнопка «Назад» для возвращения к списку картинок.
4. Добавлена возможность выхода из аккаунта:
- по нажатию на кнопку выхода нужно показать предупреждение и запросить подтверждение выхода; если пользователь подтверждает выход из аккаунта, то:
    - удаляется значение authToken из OAuth2TokenStorage;
    - очищаются куки (cookie) веб-браузера (нужно вызывать HTTPCookieStorage.shared.removeCookies(since: .distantPast)) — в противном случае при - открытии браузера не будут показаны поля для ввода логина и пароля;
    - rootViewController заменяется на SplashViewController (выполняется по аналогии со switchToTabBarController, только нужно перейти не на TabBarController, а на SplashViewController).
5. авлено логирование ошибок в методы сервиса ImagesListService:
- Добавлено сообщение об ошибке в консоль на полученный failure в методах сервиса;
- Обработаны ошибки декодирования objectTask, есть информация об ошибке и о данных, которые пытались декодировать;
- Сообщения должны быть одинакового вида, можете придерживаться такого формата [название метода и сервиса]: [тип ошибки] [параметры с которыми получили ошибку].
